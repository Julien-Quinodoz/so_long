/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_split.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jquinodo <jquinodo@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/01 09:58:08 by jquinodo          #+#    #+#             */
/*   Updated: 2024/10/17 09:16:50 by jquinodo         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

static int	word_count(const char *str, char c);
static char	*fill_word(const char *str, int start, int end);
static void	*ft_free(char **strs, int count);
static void	ft_initiate_vars(size_t *i, int *j, int *s_word);

char	**ft_split(const char *s, char c)
{
	char	**res;
	size_t	i;
	int		j;
	int		s_word;

	ft_initiate_vars(&i, &j, &s_word);
	res = ft_calloc((word_count(s, c) + 1), sizeof(char *));
	if (!res)
		return (NULL);
	while (i <= ft_strlen(s))
	{
		if (s[i] != c && s_word < 0)
			s_word = i;
		else if ((s[i] == c || i == ft_strlen(s)) && s_word >= 0)
		{
			res[j] = fill_word(s, s_word, i);
			if (!(res[j]))
				return (ft_free(res, j));
			s_word = -1;
			j++;
		}
		i++;
	}
	return (res);
}

static void	ft_initiate_vars(size_t *i, int *j, int *s_word)
{
	*i = 0;
	*j = 0;
	*s_word = -1;
}

static void	*ft_free(char **strs, int count)
{
	int	i;

	i = 0;
	while (i < count)
	{
		free(strs[i]);
		i++;
	}
	free(strs);
	return (NULL);
}

static char	*fill_word(const char *str, int start, int end)
{
	char	*word;
	int		i;

	i = 0;
	word = malloc((end - start + 1) * sizeof(char));
	if (!word)
		return (NULL);
	while (start < end)
	{
		word[i] = str[start];
		i++;
		start++;
	}
	word[i] = 0;
	return (word);
}

static int	word_count(const char *str, char c)
{
	int	count;
	int	x;

	count = 0;
	x = 0;
	while (*str)
	{
		if (*str != c && x == 0)
		{
			x = 1;
			count++;
		}
		else if (*str == c)
			x = 0;
		str++;
	}
	return (count);
}
/*
Alloue (avec malloc) et renvoie un tableau de chaînes
obtenu en divisant 's' en utilisant le caractère 'c' comme délimiteur.$
(=> un tableau de tableaux, puisque les chaînes sont des tableaux de
 caractères terminés par un caractère NUL).

Nous pouvons également formuler cela sous forme de tableau de mots,
nous prenons la chaîne set nous la divisons pour obtenir un tableau
contenant chacun de ses mots. Chaque mot est séparé par un ou plusieurs c,
c'est notre délimiteur de mots.

il est également dit que notre tableau de mots doit être terminé par NUL.
Cela signifie que nous devons allouer un élément supplémentaire dans
 notre tableau, que nous pouvons définir à 0. En faisant cela, nous avons
  un moyen simple de faire une boucle sur notre tableau de mots, de la
  même manière que pour une chaîne : while(words[i] != 0).
*/
